//! Stari Kolomoni backend API project.
//!
//! # Workspace structure
//! - [`kolomoni`][crate] *(this crate)* --- provides the entire API surface,
//!   with [`actix_web`] as the server software.
//! - [`kolomoni_auth`] --- contains authentication, role,
//!   and JSON Web Token-related code.
//! - [`kolomoni_configuration`] --- contains the entire configuration schema,
//!   including code to load it and validate it.
//! - [`kolomoni_database`] --- handles the entire PostgreSQL
//!   database interaction (with [SeaORM][sea_orm] as an ORM layer).
//! - [`kolomoni_migrations`] --- contains database migrations from which the
//!   entire schema is autogenerated in [`kolomoni_database`].
//! - [`kolomoni_openapi`](../kolomoni_openapi/index.html ) --- generates an OpenAPI schema for the entire API surface.
//!   Most annotations from which this is generated are present near each endpoint function in
//!   [`kolomoni::api::v1`][crate::api::v1], but the finishing touches are done in this crate. This crate also has a binary
//!   that serves the API schema interactively through a [RapiDoc](https://rapidocweb.com/) frontend.
//! - [`kolomoni_test`](../kolomoni_test/index.html) --- contains end-to-end tests for the backend.
//! - [`kolomoni_search`](../kolomoni_search/index.html) --- contains search engine logic.
//! - [`kolomoni_test_util`](../kolomoni_test_util/index.html) --- contains shared code for the end-to-end tests in the
//!   [`kolomoni_test`](../kolomoni_test/index.html) crate.
//!
//!
//! # Structure of this crate
//! ```markdown
//! kolomoni/src
//! |
//! |-| api/
//! | |
//! | |-| v1/
//! | |   > Contains the entire API surface.
//! | |
//! | |-> errors.rs
//! | |   > Ways of handling errors, namely the `APIError` struct, which allows
//! | |   > you to simply return an `Err(APIError)` and have it automatically
//! | |   > return a relevant HTTP error response. Also important: `EndpointResult`.
//! | |
//! | |-> macros.rs
//! | |   > Macros to avoid repeating code, such as `impl_json_response_builder`,
//! | |   > which enables structs to automatically convert to 200 OK JSON via `into_response`.
//! | |   > Also has macros to handle authentication and require permissions.
//! | |
//! | |-> openapi.rs
//! | |   > Defines commonly-used OpenAPI / `utoipa` parameters and responses,
//! | |   > which you can then use when documenting endpoint functions with
//! | |   > the `utoipa::path` macro.
//! |
//! |-> authentication.rs
//! |   > Authentication-related code, namely an Actix extractor that
//! |   > allows us to ergonomically check for roles and permissions.
//! |
//! |-> cli.rs
//! |   > Definition of the command-line interface.
//! |
//! |-> logging.rs
//! |   > Sets up logging via the `tracing` crate.
//! |
//! |-> state.rs
//! |   > Houses the entire application state that is shared between workers.
//! |   > It contains things like the current configuration and database connection.
//! ```
//!

use itertools::Itertools;
use kolomoni_configuration::Configuration;
use kolomoni_migrations::{Migrator, MigratorTrait};
use miette::{Context, IntoDiagnostic, Result};
use sea_orm::{Database, DatabaseConnection};
use sea_orm_migration::MigrationStatus;
use tracing::info;


pub mod api;
pub mod authentication;
pub mod cli;
pub mod logging;
pub mod state;

#[cfg(feature = "with_test_facilities")]
pub mod testing;

pub async fn apply_pending_migrations(database_connection: &DatabaseConnection) -> Result<()> {
    let migrations_status = Migrator::get_migration_with_status(database_connection)
        .await
        .into_diagnostic()
        .wrap_err("Failed to check current database migration status.")?;

    let pending_migrations = migrations_status
        .into_iter()
        .filter(|migration| migration.status() == MigrationStatus::Pending)
        .collect::<Vec<_>>();

    if pending_migrations.is_empty() {
        info!("No pending database migrations.");
        return Ok(());
    }


    let num_pending_migrations = pending_migrations.len();
    let pending_migration_names = pending_migrations
        .into_iter()
        .map(|migration| migration.name().to_string())
        .join(", ");

    info!(
        "There are {} pending migrations: {}",
        num_pending_migrations, pending_migration_names
    );


    info!("Applying migrations.");
    Migrator::up(database_connection, None)
        .await
        .into_diagnostic()
        .wrap_err("Could not apply database migration.")?;
    info!("Migrations applied.");

    Ok(())
}



pub async fn connect_and_set_up_database_with_full_url(
    database_url: String,
) -> Result<DatabaseConnection> {
    let database = Database::connect(database_url)
        .await
        .into_diagnostic()
        .wrap_err("Could not initialize connection to PostgreSQL database.")?;

    info!("Database connection established.");

    apply_pending_migrations(&database).await?;

    Ok(database)
}

/// Connect to PostgreSQL database as specified in the configuration file
/// and apply any pending migrations.
pub async fn connect_and_set_up_database(config: &Configuration) -> Result<DatabaseConnection> {
    connect_and_set_up_database_with_full_url(format!(
        "postgres://{}:{}@{}:{}/{}",
        config.database.username,
        config.database.password,
        config.database.host,
        config.database.port,
        config.database.database_name,
    ))
    .await
}
