//! Stari Kolomoni backend API project.
//!
//! TODO This needs an update.
//!
//! # Workspace structure
//! - [`kolomoni`][crate] *(this crate)* --- provides the entire API surface,
//!   with [`actix_web`] as the server software.
//! - [`kolomoni_auth`] --- contains authentication, role,
//!   and JSON Web Token-related code.
//! - [`kolomoni_configuration`] --- contains the entire configuration schema,
//!   including code to load it and validate it.
//! - [`kolomoni_database`] --- handles the entire PostgreSQL
//!   database interaction (with [SeaORM][sea_orm] as an ORM layer).
//! - [`kolomoni_migrations`] --- contains database migrations from which the
//!   entire schema is autogenerated in [`kolomoni_database`].
//! - [`kolomoni_openapi`](../kolomoni_openapi/index.html ) --- generates an OpenAPI schema for the entire API surface.
//!   Most annotations from which this is generated are present near each endpoint function in
//!   [`kolomoni::api::v1`][crate::api::v1], but the finishing touches are done in this crate. This crate also has a binary
//!   that serves the API schema interactively through a [RapiDoc](https://rapidocweb.com/) frontend.
//! - [`kolomoni_test`](../kolomoni_test/index.html) --- contains end-to-end tests for the backend.
//! - [`kolomoni_search`](../kolomoni_search/index.html) --- contains search engine logic.
//! - [`kolomoni_test_util`](../kolomoni_test_util/index.html) --- contains shared code for the end-to-end tests in the
//!   [`kolomoni_test`](../kolomoni_test/index.html) crate.
//!
//!
//! # Structure of this crate
//! ```markdown
//! kolomoni/src
//! |
//! |-| api/
//! | |
//! | |-| v1/
//! | |   > Contains the entire API surface.
//! | |
//! | |-> errors.rs
//! | |   > Ways of handling errors, namely the `APIError` struct, which allows
//! | |   > you to simply return an `Err(APIError)` and have it automatically
//! | |   > return a relevant HTTP error response. Also important: `EndpointResult`.
//! | |
//! | |-> macros.rs
//! | |   > Macros to avoid repeating code, such as `impl_json_response_builder`,
//! | |   > which enables structs to automatically convert to 200 OK JSON via `into_response`.
//! | |   > Also has macros to handle authentication and require permissions.
//! | |
//! | |-> openapi.rs
//! | |   > Defines commonly-used OpenAPI / `utoipa` parameters and responses,
//! | |   > which you can then use when documenting endpoint functions with
//! | |   > the `utoipa::path` macro.
//! |
//! |-> authentication.rs
//! |   > Authentication-related code, namely an Actix extractor that
//! |   > allows us to ergonomically check for roles and permissions.
//! |
//! |-> cli.rs
//! |   > Definition of the command-line interface.
//! |
//! |-> logging.rs
//! |   > Sets up logging via the `tracing` crate.
//! |
//! |-> state.rs
//! |   > Houses the entire application state that is shared between workers.
//! |   > It contains things like the current configuration and database connection.
//! ```
//!


// TODO -- things to do, in rough order: --
// TODO migrate to the new database structure, which will remove and add some new endpoints
// TODO refactor actix extractors/data into a better structure
// TODO refactor non-library things out of this crate into kolomoni_core (including API request/response models?)
// TODO refactor how state is updated locally, so it can be more general than just for the search crate
// TODO rework search crate with either a deep-dive into tantivy or by removing tantivy and using manual similarity metrics
// TODO rework the kolomoni_sample_data to be rust, and to ingest the Google Sheets document for seeding data
// TODO migrate tests to new database structure
// TODO for clarity, create two directories: `crates` and `binaries`, where workspaces crates will be categorized
//      (e.g. `kolomoni` + `kolomoni_openapi` can go in `binaries`)
// TODO review documentation, especially top-level crate docs (+ check for cargo doc warnings)
// TODO review CI
// TODO review makefile
// TODO review unused dependencies

use std::time::Duration;

use kolomoni_configuration::DatabaseConfiguration;
use kolomoni_migrations::core::{
    errors::{MigrationApplyError, StatusError},
    migrations::MigrationsWithStatusOptions,
    MigrationStatus,
};
use miette::Result;
use sqlx::{
    postgres::{PgConnectOptions, PgPoolOptions},
    PgConnection,
    PgPool,
};
use thiserror::Error;


pub mod api;
pub mod authentication;
pub mod cli;
pub mod logging;
pub mod state;

#[cfg(feature = "with_test_facilities")]
pub mod testing;


#[derive(Debug, Error)]
pub enum PendingMigrationApplyError {
    #[error("failed to retrieve database migration status")]
    StatusError(
        #[from]
        #[source]
        StatusError,
    ),

    #[error("failed to apply migration")]
    MigrationApplyError(
        #[from]
        #[source]
        MigrationApplyError,
    ),
}

// TODO needs logging
pub async fn apply_pending_migrations(
    database_connection: &mut PgConnection,
) -> Result<(), PendingMigrationApplyError> {
    let manager = kolomoni_migrations::migrations::manager();

    let migrations = manager
        .migrations_with_status(
            database_connection,
            MigrationsWithStatusOptions::strict(),
        )
        .await?;

    let pending_migrations = migrations
        .into_iter()
        .filter(|migration| migration.status() == &MigrationStatus::Pending)
        .collect::<Vec<_>>();


    if pending_migrations.is_empty() {
        return Ok(());
    }


    for pending_migration in pending_migrations {
        pending_migration.execute_up(database_connection).await?;
    }

    Ok(())
}


pub async fn establish_database_connection_pool(
    database_configuration: &DatabaseConfiguration,
) -> Result<PgPool, sqlx::Error> {
    let mut connection_options = PgConnectOptions::new_without_pgpass()
        .application_name(&format!(
            "stari-kolomoni-backend-api_v{}",
            env!("CARGO_PKG_VERSION")
        ))
        .statement_cache_capacity(200)
        .host(&database_configuration.host)
        .port(database_configuration.port)
        .username(&database_configuration.username)
        .database(&database_configuration.database_name);

    if let Some(password) = &database_configuration.password {
        connection_options = connection_options.password(password.as_str());
    }


    PgPoolOptions::new()
        .idle_timeout(Some(Duration::from_secs(60 * 20)))
        .max_lifetime(Some(Duration::from_secs(60 * 60)))
        .min_connections(1)
        .max_connections(10)
        .test_before_acquire(true)
        .connect_with(connection_options)
        .await
}
